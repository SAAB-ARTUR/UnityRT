RWTexture2D<float4> RenderTarget;

#pragma max_recursion_depth 4 // sätts den här till en för låg siffra kraschar Unity om man försöker skicka fler rays från en .shader-fil, 
// det verkar som att den behöver vara minst lika stor som max antal tillåtna studsar för att Unity inte ska krascha

struct RayPayload // vissa av dessa fält finns just nu för test-syften, vi får se i slutändan vilka som faktiskt behövs för att uppfylla våra syften
{
    float3 hitIndex;
    /*int nrOfInteractions;
    float3 startingPoint;           // ray's starting point
    float3 direction;               // direction of the ray
    float3 intersectionPoint;       // where the ray intersects the next object, starting point for potential new ray    
    bool spawnNewRay;               // should a new ray be spawned after the current ray has hit something
    float3 newDirection;            // in what direction should the new ray travel
    float3 points[4];               // array containing points of the ray (origin is the first, update the rest with intersection points)*/
};

RaytracingAccelerationStructure g_AccelStruct	: register(t1, space1);

//SamplerState sampler_g_EnvTexture : register(s0, space1);

// Input
float4x4                        g_InvViewMatrix;
float4x4                        g_ViewMatrix;
float                           g_Zoom;
float3                          g_RaySource;

// Output
RWTexture2D<float3>                g_Output;

[shader("miss")]
void MainMissShader(inout RayPayload payload : SV_RayPayload)
{
    payload.hitIndex = float3(0,0,0);
    //payload.spawnNewRay = false;
}

[shader("raygeneration")]
void MainRayGenShader()
{
    uint2 LaunchIndex = DispatchRaysIndex().xy;
    uint2 LaunchDim = DispatchRaysDimensions().xy;

    float2 frameCoord = float2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1);

    const uint subSampleCount = 4;

    float2 subSamplePos[subSampleCount] = { float2(0.25, 0.25), float2(0.75, 0.25), float2(0.75, 0.75), float2(0.25, 0.75) };

    // The ray origin is the camera position in world space.
    float3 rayOrigin = float3(g_InvViewMatrix[0][3], g_InvViewMatrix[1][3], g_InvViewMatrix[2][3]);

    float aspectRatio = (float)LaunchDim.x / (float)LaunchDim.y;

    float3 hitIndex = float3(0.1, 0.3, 0.4);

    for (uint i = 0; i < 1; i++)
    {
        float2 ndcCoords = (frameCoord + subSamplePos[i]) / float2(LaunchDim.x - 1, LaunchDim.y - 1) ;
        
        ndcCoords = ndcCoords * 2 - float2(1, 1);
        ndcCoords = ndcCoords * g_Zoom;

        float3 viewDirection = normalize(float3(ndcCoords.x * aspectRatio, ndcCoords.y, -1));

        // Rotate the ray from view space to world space.
        float3 rayDirection = normalize(mul((float3x3)g_InvViewMatrix, viewDirection));

        RayDesc ray;
        ray.Origin = rayOrigin;
        ray.Direction = rayDirection;
        ray.TMin = 0;
        ray.TMax = 1e20f;

        RayPayload payload;
        payload.hitIndex = float3(0,0,0);
        //payload.nrOfInteractions = 0;
        //payload.startingPoint = rayOrigin;
        //payload.direction = rayDirection;        
    
        uint missShaderIndex = 0;
        TraceRay(g_AccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload);
        hitIndex = payload.hitIndex;


        /*while (payload.spawnNewRay)
        {
            // spawn new ray (nya rays skapas alltid i mainshader, closestHit shaders uppdaterar bara payloaden ???)
            RayDesc ray;
            ray.Origin = payload.intersectionPoint;
            ray.Direction = payload.newDirection;
            ray.TMin = 0;
            ray.TMax = 1e20f;
        }*/

    }

    g_Output[frameCoord] = hitIndex;
}
