// Each #kernel tells which function to compile; you can have many kernels
//#include "UnityRayQuery.cginc"
//#pragma require inlineraytracing
#pragma kernel CSMain

//RaytracingAccelerationStructure g_AccelStruct;

struct PerRayData {
    float beta;
    uint ntop;
    uint nbot;
    uint ncaust;
    float delay;
    float curve;
    float xn;
    float qi;    
    float theta;
    float phi; // angle from source to target in the xz-plane
    uint contributing; // if ray 'hits' a target
    float TL; // transmission loss
    uint target; // index of the target the ray is headed towards
};

RWStructuredBuffer<PerRayData> PerRayDataBuffer;
RWStructuredBuffer<float3> RayPositionsBuffer;
//RWStructuredBuffer<float3> debugBuf; // used to debug data on the gpu, fill it with values and write them on the cpu
RWStructuredBuffer<PerRayData> ContributingRayData;
StructuredBuffer<float2> ContributingAnglesData;
StructuredBuffer<float2> FreqsAndDampData;

struct Target {
    float xpos;
    float ypos;
    float zpos;
    float phi;
};

StructuredBuffer<Target> targetBuffer;
StructuredBuffer<uint> rayTargets;

float4x4 _SourceCameraToWorld;
float4x4 _CameraInverseProjection;

uint _BELLHOPSIZE;
float deltas;
uint _MAXBOTTOMHITS;
uint _MAXSURFACEHITS;

static const float PI = 3.14159265f;

float depth;
float theta;
uint ntheta;
float3 srcDirection;
float3 srcPosition;
float dtheta;

uint freqsdamps;

struct SSP_Data 
{
    float depth;
    float velocity;
    float derivative1;
    float derivative2;
};

StructuredBuffer<SSP_Data> _SSPBuffer;
#include "BSSP.cginc"

//-------------------------------------
//- RAY

struct Ray
{
    float3 origin;
    float3 direction;
    float3 energy;
    uint nrOfInteractions;
};

#include "BTrace.cginc"
#include "RayCreation.cginc"

//-------------------------------------
//- RAYHIT

struct RayHit
{
    float3 position;
    float distance;
    float3 normal;    
    bool sendNewRay;
};

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);    
    hit.sendNewRay = false;
    return hit;
}

//#include "HitHandler.cginc" // was first meant to be used for an implementation based on the rt acceleration structure

[numthreads(1,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float2 angles = CreateCylindricalRay(id);

    SSP soundSpeedProfile;
    soundSpeedProfile.type = 0;   
    
    float theta = angles.x;
    float phi = angles.y;   

    float2 xs = { 0.0,  mul(_SourceCameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).y };

    float xdiff = targetBuffer[id.x].xpos - mul(_SourceCameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).x;
    float zdiff = targetBuffer[id.x].zpos - mul(_SourceCameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).z;    

    float2 xr = { sqrt((pow(xdiff, 2.0) + pow(zdiff, 2.0))), targetBuffer[id.x].ypos };    

    PerRayData prd;    
    
    uint offset = (id.y + id.x * ntheta) * _BELLHOPSIZE;
    btrace(soundSpeedProfile, theta, dtheta, xs, xr, depth, deltas, _MAXSURFACEHITS, _MAXBOTTOMHITS, offset, phi, prd, id);
    
    PerRayDataBuffer[id.y + id.x * ntheta] = prd;
}

#include "BTraceContributing.cginc"
#pragma kernel TraceContributingRays
[numthreads(1, 1, 1)]
void TraceContributingRays(uint3 id : SV_DispatchThreadID)
{
    // id is 1D, id.y is the only thing needed
    SSP soundSpeedProfile;
    soundSpeedProfile.type = 0;    

    float theta = ContributingAnglesData[id.y].x;
    float phi = ContributingAnglesData[id.y].y;    
    float2 xs = { 0.0,  mul(_SourceCameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).y };    

    float xdiff = targetBuffer[rayTargets[id.x]].xpos - mul(_SourceCameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).x;
    float zdiff = targetBuffer[rayTargets[id.x]].zpos - mul(_SourceCameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).z;

    float2 xr = { sqrt((pow(xdiff, 2.0) + pow(zdiff, 2.0))), targetBuffer[rayTargets[id.x]].ypos };

    PerRayData prd;    
    
    btrace_contributing(soundSpeedProfile, theta, dtheta, xs, xr, depth, deltas, _MAXSURFACEHITS, _MAXBOTTOMHITS, phi, prd);

    ContributingRayData[id.y] = prd;
}
